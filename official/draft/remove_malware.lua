--[[
    Infocyte Extension
    Name: Removes malware
    Type: Action
    Description: Kills persistence and running malware
    Author: Infocyte
    Guid: 2a7e0aff-c47c-45f7-8065-580689f89ad2
    Created: 20200123
    Updated: 20200123 (Gerritz)
--]]

--[[ SECTION 1: Inputs --]]

processes_to_kill = {

}
registrykeys_to_delete = {

}
files_to_delete = {

}


--[[ SECTION 2: Functions --]]

-- FileSystem Functions --
function path_exists(path)
    --[[
        Check if a file or directory exists in this path. 
        Input:  [string]path -- Add '/' on end of the path to test if it is a folder
        Output: [bool] Exists
                [string] Error message -- only if failed
    ]] 
   local ok, err = os.rename(path, path)
   if not ok then
      if err == 13 then
         -- Permission denied, but it exists
         return true
      end
   end
   return ok, err
end

function get_filename(path)
    match = path:match("^.+[\\/](.+)$")
    return match
end

-- Infocyte Powershell Functions --
powershell = {}
function powershell.run_command(command)
    --[[
        Input:  [String] Small Powershell Command
        Output: [Bool] Success
                [String] Output
    ]]
    if not hunt.env.has_powershell() then
        throw "Powershell not found."
    end

    if not command or (type(command) ~= "string") then 
        throw "Required input [String]command not provided."
    end

    print("Initiatializing Powershell to run Command: "..command)
    cmd = ('powershell.exe -nologo -nop -command "& {'..command..'}"')
    pipe = io.popen(cmd, "r")
    output = pipe:read("*a") -- string output
    ret = pipe:close() -- success bool
    return ret, output
end

function powershell.run_script(psscript)
    --[[
        Input:  [String] Powershell script. Ideally wrapped between [==[ ]==] to avoid possible escape characters.
        Output: [Bool] Success
                [String] Output
    ]]
    debug = debug or true
    if not hunt.env.has_powershell() then
        throw "Powershell not found."
    end

    if not psscript or (type(psscript) ~= "string") then 
        throw "Required input [String]script not provided."
    end

    print("Initiatializing Powershell to run Script")
    local tempfile = os.getenv("systemroot").."\\temp\\ic"..os.tmpname().."script.ps1"
    local f = io.open(tempfile, 'w')
    script = "# Ran via Infocyte Powershell Extension\n"..psscript
    f:write(script) -- Write script to file
    f:close()

    -- Feed script (filter out empty lines) to Invoke-Expression to execute
    -- This method bypasses translation issues with popen's cmd -> powershell -> cmd -> lua shinanigans
    local cmd = 'powershell.exe -nologo -nop -command "gc '..tempfile..' | Out-String | iex'
    print("Executing: "..cmd)
    local pipe = io.popen(cmd, "r")
    local output = pipe:read("*a") -- string output
    if debug then 
        for line in string.gmatch(output,'[^\n]+') do
            if line ~= '' then print("[PS]: "..line) end
        end
    end
    local ret = pipe:close() -- success bool
    os.remove(tempfile)
    if ret and string.match( output, 'FullyQualifiedErrorId' ) then
        ret = false
    end
    return ret, output
end


-- PowerForensics (optional)
function powershell.install_powerforensics()
    --[[
        Checks for NuGet and installs Powerforensics
        Output: [bool] Success
    ]]
    if not powershell then 
        hunt.error("Infocyte's powershell lua functions are not available. Add Infocyte's powershell.* functions.")
        throw "Error"
    end
    script = [==[
        # Download/Install PowerForensics
        $n = Get-PackageProvider -name NuGet
        if ($n.version.major -lt 2) {
            if ($n.version.minor -lt 8) {
                Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Scope CurrentUser -Force
            }
        }
        if (-NOT (Get-Module -ListAvailable -Name PowerForensics)) {
            Write-Host "Installing PowerForensics"
            Install-Module -name PowerForensics -Scope CurrentUser -Force
        }
    ]==]
    ret, output = powershell.run_script(script)
    if ret then 
        hunt.debug("Powershell Succeeded:\n"..output)
    else 
        hunt.error("Powershell Failed:\n"..output)
    end
    return ret
end

--[[ SECTION 3: Actions --]]

host_info = hunt.env.host_info()
osversion = host_info:os()
hunt.debug("Starting Extention. Hostname: " .. host_info:hostname() .. ", Domain: " .. host_info:domain() .. ", OS: " .. host_info:os() .. ", Architecture: " .. host_info:arch())

-- Kill Processes
s = ''
for i, v in ipairs(processes_to_kill) do
    s = s.."\nTerm["..i.."]: "..v -- concatenate key/value pairs
end
hunt.log("Finding and killing processes that match the following search terms (name, path, or pid):"..s)

kill_list = {}
-- List running processes
e = {}
procs = hunt.process.list()
for _, proc in pairs(procs) do
    procpath = string.lower(proc:path())
    procname = get_filename(procpath) or 'error'
    if procname == 'error' then
        table.insert(e, proc:pid())
        hunt.verbose("Could not access pid "..proc:pid()..": "..proc:path()..". Normal for a system process.") 
        goto continue
    end   

    -- Search procs for your list of kill keywords (name, pid, path)
    for _, item in ipairs(processes_to_kill) do
        if (type(item) == 'number') and (proc:pid() == item) then 
            hunt.verbose("Found PID: "..item)
            kill_list[proc:pid()] = proc
        elseif (type(item) == 'string') then
            if string.find(procname, item:lower()) or (procpath == item:lower()) then 
                hunt.verbose("Found name/path: "..item)
                kill_list[proc:pid()] = proc
            end
        end
    end
    ::continue::
end

-- Kill 'em
n = 0
for pid, proc in pairs(kill_list) do
    out, err = hunt.process.kill_pid(pid)
    if out then
        n = n + 1
        hunt.log("Killed "..get_filename(proc:path()).." [pid: "..proc:pid().."] with image path: "..proc:path())
    else 
        hunt.error("Could not kill "..get_filename(proc:path()).." [pid: "..proc:pid().."] with image path "..proc:path()..": "..err)
    end
end

hunt.log("Killed "..n.." processes. "..(#kill_list-n).." failed.")

s = nil
for _, v in ipairs(e) do
    if not s then 
        s = v
    else 
        s = s..","..v -- concatenate key/value pairs
    end
end
hunt.verbose("Could not retrieve info for "..#e.." locked system processes with pids: {"..s.."}")


-- Kill Files



-- All OS-specific instructions should be behind an 'if' statement
if hunt.env.is_windows() then
    -- Insert your Windows Code


elseif hunt.env.is_macos() then
    -- Insert your MacOS Code


elseif hunt.env.is_linux() or hunt.env.has_sh() then
    -- Insert your POSIX-compatible (linux) Code


else
    hunt.warn("Not a compatible operating system for this extension [" .. host_info:os() .. "]")
end
